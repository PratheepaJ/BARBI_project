---
title: "LDA- variational Bayes on Zymbo microbial community data"
author: "Pratheepa Jeganathan"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
---

We have 10 negative control samples and serial dilution of ZymoBIOMICS® Microbial Community Standard.

Looking at the DADA2 pipeline ASVs 2, 3, 4, 5, 6, 7, 8, 11, 17, 37, 22 are in the ZymoBIOMICS® Microbial Community Standard.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
  message = FALSE, 
  warning = FALSE, 
  fig.width = 16, 
  fig.height = 10)
```

Loading packages
```{r}
library(phyloseq)
library(ggplot2)
library(magrittr)
library(dplyr)
library(reshape2)
library(rstan)
library(RColorBrewer)
library(wesanderson)
#devtools::install_github("jakobbossek/ggheatmap")
library(ggheatmap)
```


## Read phyloseq and exploratory analysis

```{r}
ps = readRDS("./Data/ps_zymo.rds")
if(dim(otu_table(ps))[1]!=ntaxa(ps)){
  otu_table(ps) = t(otu_table(ps))
  }
```

change order of sample names
```{r}
ncont = paste0("NegativeControl.", seq(1, 10))
stan = paste0("Standard.Dilution.1.",c(1, 6, 36, 216, 1296, 7776, 46656, 279936))

sample_data(ps)$Name = factor(sample_data(ps)$Name, levels = c(ncont,stan))

sample_names(ps) = as.character(sample_data(ps)$Name)
```

Store sequence variants, ASVs, ASV.genus, ASV.genus.species
```{r}
ASV = as.character(paste0("ASV_", seq(1,ntaxa(ps))))

ASV.Genus = paste0("ASV_", seq(1,ntaxa(ps)), "_", as.character(tax_table(ps)[,6]))

ASV.Genus.Species = paste0(ASV, "_", as.character(tax_table(ps)[,6]), "_", as.character(tax_table(ps)[,7]))

df.ASV = data.frame(seq.variant = taxa_names(ps), ASV = ASV, ASV.Genus = ASV.Genus, ASV.Genus.Species = ASV.Genus.Species)
```


```{r }
taxa_names(ps) = df.ASV$ASV.Genus.Species
```

## Microbial composition of the ZymoBIOMICS® microbial community standard (Zymo Research, Irvine, CA) measured 

True ASVs at genus level

```{r}
# true.com.ASV = taxa_names(ps)[which(tax_table(ps)[,6] %in% c("Bacillus","Listeria","Staphylococcus", "Lactobacillus", "Escherichia/Shigella", "Enterococcus", "Salmonella", "Pseudomonas"))]
true.com.ASV = taxa_names(ps)[c(2:8,11,17,37,22)]
ps.true = transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.true = prune_taxa(true.com.ASV, ps.true)
ps.true
```


### Create a list of true ASVs in each diluted sample

```{r}
true.com.ASV = taxa_names(ps)[c(2:8,11,17,22,37)]
# true.com.ASV = taxa_names(ps)[which((tax_table(ps)[,6] %in% c("Bacillus","Listeria","Staphylococcus", "Lactobacillus", "Escherichia/Shigella", "Enterococcus", "Salmonella", "Pseudomonas")))]

# true.com.ASV = taxa_names(ps)[which((tax_table(ps)[,6] %in% c("Bacillus","Listeria","Staphylococcus", "Lactobacillus", "Escherichia/Shigella", "Enterococcus", "Salmonella", "Pseudomonas"))&(!is.na(tax_table(ps)[,7])))]

diluted.sample.names = sample_names(ps)[3:10]

trueSeq = function(sample.name, true.com.ASV){
  df.sample.i = data.frame(ot = otu_table(ps)[, sample.name])
  names(df.sample.i) = "ot"
  df.sample.i = mutate(df.sample.i, ASV = rownames(df.sample.i))
  df.sample.i.true.seq = filter(df.sample.i, (ot > 0) & (as.character(ASV) %in% true.com.ASV))
  true.seq.sample.i = as.character(df.sample.i.true.seq$ASV)
  return(true.seq.sample.i)
}


true.seq.all.samples = lapply(diluted.sample.names, FUN = trueSeq, true.com.ASV = true.com.ASV)

##true.seq.all.samples
```

### Number of true ASVs in each dilution series sample
```{r}
number.of.true.ASVs = lapply(true.seq.all.samples, 
  function(x) {length(x)})
number.of.true.ASVs
```

### Number of unique true ASV in all samples
```{r}
number.of.unique.ASVs.in.all.samples = length(unique(unlist(true.seq.all.samples)))
number.of.unique.ASVs.in.all.samples
```


### Check the percentage of eleven ASVs in each dilution series sample

```{r}
ps.prop = transform_sample_counts(ps, function(otu) otu/sum(otu)*100)
ps.true = prune_taxa(unique(unlist(true.seq.all.samples)), ps)
ps.prop.true = prune_taxa(taxa_names(ps.true), ps.prop)
dt = otu_table(subset_samples(ps.prop.true, 
  SampleType == "Standard")) %>% data.frame()
colnames(dt) = sample_data(subset_samples(ps.prop.true, 
  SampleType == "Standard"))$Name
#rownames(dt) = df.ASV$ASV.Genus[which(as.character(df.ASV$ASV.Genus.Species) %in% rownames(dt))]
rownames(dt) = df.ASV$ASV.Genus.Species[which(as.character(df.ASV$ASV.Genus.Species) %in% rownames(dt))]
dt = round(dt, digits = 0)
library(knitr)
kable(dt)
```

### Adding blocks

We have only one block of samples.

```{r adding_blocks}
blocks = rep("Set1", nsamples(ps))

sample_data(ps)$block = blocks
```

Identify the species that are not present in at least one `SampleType == Standard` sample and removed them from the phyloseq object. Label these species as contaminants. 

```{r filter_taxa}
ps = prune_taxa(taxa_sums(ps) > 0, ps)
ps.standard = subset_samples(ps, SampleType %in% c("Standard"))
prevTaxaP = apply(otu_table(ps.standard), 1, function(x){sum(x>0)})

Contaminants1 = names(prevTaxaP)[prevTaxaP == 0]
length(Contaminants1)
```

```{r}
ps = prune_taxa(prevTaxaP > 0, ps)
ps
```

We identified 142 ASVs not is any dilution series samples and they are classified as contaminants before using LDA.
  
See a summary of the `Standard` and `Negative` samples in each block. 

```{r summary_stat}
table(sample_data(ps)$SampleType, sample_data(ps)$block)
```

```{r}
colSums(otu_table(ps))
```

##      Prepare the phyloseq object for the Bayesian inference

We use Bayesian inference to identify contaminants in each block separately to account for the batch-effects of contamination. In Zymo data, we have batch effects.

Thus, split the phyloseq object into multiple phyloseq objects corresponding to each block, and store the phyloseq objects as a list of phyloseq objects, `psByBlock`. 

Select negative control samples from each block and store as a list of phyloseq objects, `psNCbyBlock`. 

Select all species that have a prevalence of zero (i.e., have zero reads) in all negative control samples for each block and store as a list of phyloseq objects, `psallzeroInNC`.

Select all plasma samples from each block and store as a list of phyloseq objects, `psPlByBlock`.

```{r list_of_phyloseq}
source("psBlockResults.R")
psBlockResult = psBlockResults(ps, 
  sampleTypeVar = "SampleType", caselevels = c("Standard"), controllevel="Negative", sampleName = "Name", blockVar = "block")

psByBlock = psBlockResult[[1]]
psNCbyBlock = psBlockResult[[2]]
psallzeroInNC = psBlockResult[[3]]
psPlByBlock = psBlockResult[[4]]

# st = sample_names(psByBlock[[1]])[-c(4:10)]
# psByBlock[[1]] = subset_samples(psByBlock[[1]], SampleCode %in% st)
```

## LDA-VB

Each sample is modeled as having a mixture of topics, with each ASV drawn from a topic based on mixing proportions.


### LDA on specimen and control samples

We choose the number of topics to be 4.

Read stan model
```{r eval=FALSE}
f <- stan_model(file = "lda.stan")
```

Make stan data
```{r}
K = 4 # number of topics
ps = psByBlock[[1]] 
short.sample.names = c(paste0("NC.", c(1,10)), paste0("Di.", seq(1,8)), paste0("NC.", seq(2,9)))
sample_names(ps) = short.sample.names

x = t(get_taxa(ps))
dimnames(x) = NULL
stan.data <- list(K = K, 
  V = ncol(x), 
  D = nrow(x), 
  n = x, 
  alpha = rep(1, K), 
  gamma = rep(0.5, ncol(x))
)
```

```{r eval=FALSE}
stan.fit = vb(f, 
  data = stan.data, 
  output_samples = 1000, 
  eta = 1, 
  adapt_engaged = FALSE)


saveRDS(stan.fit, file = "./Results/stan_vb_Zymo.rds")
```

```{r}
stan.fit = readRDS("./Results/stan_vb_Zymo.rds")
```

### Extract posterior samples 
- $\beta$ and $\theta$
```{r}
samples <- rstan::extract(stan.fit)
```

### Posterior distribution of topic in each sample 
- $\theta$ for each sample
```{r}
theta = samples$theta # chain * sample * topic
# find theta distirbution of each topic in each sample
names(theta) = c("theta", "Sample", "Topic")
theta.all = melt(theta)
colnames(theta.all) = c("Chain", "Sample", "Topic", "topic.dis")
theta.all$Sample = factor(theta.all$Sample)
levels(theta.all$Sample) = sample_names(ps)
theta.all$Topic = factor(theta.all$Topic)
levels(theta.all$Topic) = c(paste0("Topic_", seq(1,K)))

# add control or dilution series
theta.all =  mutate(theta.all, Group = ifelse(substr(Sample,1,1)=="D","Dilution", "Control"))

theta.all$Group = factor(theta.all$Group)
```

### Plot topic distribution in each sample 
```{r}
col.topic = c(wes_palette("Cavalcanti1", n = 2), wes_palette("Darjeeling1", n = 2))
# p = ggplot() + 
#   geom_density(data = theta.all ,aes(x = topic.dis, y = ..scaled.., col = Topic, fill=Topic)) + 
#   facet_grid(Sample ~ Group, scales = "fixed") + 
#   scale_color_manual(values = col.topic)+
#   scale_fill_manual(values = col.topic)+
#   ylab("density") +
#   xlab("") + 
#   ggtitle("") + 
#   theme(plot.title = element_text(hjust = 0.5, size = 15), strip.text.y= element_text(size = 12), strip.text.x = element_text(size = 12))

p = ggplot() + 
  geom_density(data = theta.all ,aes(x = topic.dis, y = ..scaled.., linetype = Topic)) + 
  facet_grid(Sample ~ Group, scales = "fixed") +
  ylab("density") +
  xlab("") + 
  ggtitle("") + 
  theme(plot.title = element_text(hjust = 0.5, size = 15), 
    strip.text.y= element_text(size = 12), 
    strip.text.x = element_text(size = 12))
```

We chose four topics because two topics always dominated in dilution series samples. 
<!-- When we chose three topics, one of the topics dominated in dilution series sample is also dominated in control sample. Topic 1 is contaminant topic because it's only dominated in control samples. Topic 3 is also a contaminant topic because $\theta$ distribution range is less than .25 in all dilution samples. Topic 2 is real species topic because it is highly dominated in dilution series samples. Topic 4 is mix of mostly real and some contribution from contaminant species. -->

```{r}
p
ggsave("./Figures/LDA_Zymo2.eps", plot = p, width = 12, height = 16)
```


### boxplot as in Kris's paper
```{r}
p = ggplot(data = theta.all) + 
  geom_boxplot(aes(x = Sample, y = log(topic.dis))) + 
  facet_grid(Topic ~ Group, scales = "free_x")+
  ylab(bquote(log(theta[k]))) + 
  ggtitle("") + 
  theme(plot.title = element_text(hjust = 0.5, size = 15), 
    strip.text.y= element_text(size = 12), 
    strip.text.x = element_text(size = 12))
p
ggsave("./Figures/LDA_Zymo_boxplot.eps", plot = p, width = 10, height = 6)
```

### ASV distribution in each topic
```{r}
beta = samples$beta
beta.all = melt(beta)
colnames(beta.all) = c("Chain", "Topic", "ASV", "ASV.distribution")
beta.all$Topic = factor(beta.all$Topic)
levels(beta.all$Topic) = c(paste0("Topic_", seq(1,K)))
beta.all$ASV = factor(beta.all$ASV)
levels(beta.all$ASV) = df.ASV$ASV.Genus
```

```{r}
ggheatmap(
  beta.all %>%
  group_by(Topic, ASV) %>%
  summarise(log_median_beta = log(median(ASV.distribution, na.rm = TRUE))) %>%
  as.data.frame(),
  id.vars = c("ASV", "Topic"),
  value.name = "log_median_beta"
) + ggtitle("ASV distribution in each topic") + 
  theme(plot.title = element_text(hjust = 0.5, size = 12), axis.text.x = element_text(size = 12), axis.text.y = element_text(size = 12)) 
```

<!-- ###  Can we look at the ASV distribution in each topic in the following way? -->
```{r include = FALSE, eval=FALSE}
### Posterior distirbution of ASV in each topic
beta = samples$beta
beta.all = melt(beta)
colnames(beta.all) = c("Chain", "Topic", "ASV", "ASV.distribution")
beta.all$Topic = factor(beta.all$Topic)
levels(beta.all$Topic) = c(paste0("Topic_", seq(1,K)))
beta.all$ASV = factor(beta.all$ASV)
levels(beta.all$ASV) = df.ASV$ASV.Genus
```


```{r include = FALSE, eval=FALSE}
ggplot() + 
  geom_density(data = beta.all ,aes(x = ASV.distribution, y = ..scaled.., col = Topic, fill = Topic)) + 
  facet_wrap(~ASV, scales = "fixed") + 
  scale_color_manual(values = col.topic)+
  scale_fill_manual(values = col.topic) + 
  ylab("density") +
  xlab("ASV distribution") + 
  ggtitle("ASV distribution in each topic") + 
  theme(plot.title = element_text(hjust = 0.5), strip.text.x= element_text(size = 6)) 
```

### Topic distribution summary in negative controls
```{r}
theta.all.ctrl = filter(theta.all, Group == "Control")
map.theta = theta.all.ctrl %>% group_by(Sample, Topic) %>% summarize(map = mean(topic.dis))
agg.theta.in.ctrl = map.theta %>% group_by(Topic) %>% summarize(mean.over.ctrl = mean(map))
agg.theta.in.ctrl
```

