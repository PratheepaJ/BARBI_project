---
title: "Testing BARBI"
author: "Pratheepa Jeganathan"
date: "8/20/2018"
output: html_document
---


We used the following [mock community](https://lakarstens.github.io/ControllingContaminants16S/Analyses/ControllingConatminants16S_decontam.html): 

ZymoBIOIC

8 bacterial species, 2 fungal species

Samples $D0, D1, \cdots , D8$: D1 - D8 diluted with microbial free water

18 ASVs are expected 

10 ASVs are unexpected.

Blank control of microbial-free water were also used.

$\frac{\alpha_{0}}{\beta_{0} = \mu_{0}}$

$\alpha_{c} = \frac{S_{j}}{S_{j0}}\alpha_{0}$ and $\beta_{c} = \beta_{0}$

Let us use $\gamma_{0}=1 $ and $\mu_{0}$ is what we observed in the one blank control.

Thus, $\alpha_{0} = 1$ and $\beta_{0} = 1/\mu_{0}$

```{r}
#library(BARBI)
library(devtools)
library(phyloseq)
library(DESeq2)
library(dplyr)
library(tidyr)
library(R.utils)
library(BiocParallel)
library(doParallel)
library(parallel)
library(HDInterval)
library(grid)
library(xtable)
library(gtable)
library(gridExtra)
library(BiocStyle)
library(magrittr)

sourceDirectory("./R")
#sourceDirectory("/Users/jpratheepa31/Dropbox/GitHub/BARBI/R")
```



Set the computational resources
```{r}
ncores = as.integer(Sys.getenv("SLURM_NTASKS"))
if(is.na(ncores)) ncores <- parallel::detectCores()
```



```{r}
## Load the dataset
load("./Data/mockDilutionsPrep.RData")
mock_ps
contaminants_ps
blank_ps
mock_ps_pure

```

```{r}
# undiluted mock microbial community sample to mostly contain the expected sequences from the mock microbial community. To evaluate this, we subset out the undiluted mock microbial sample (D0) as a new separate phyloseq object and remove the ASVs that are not present in the sample.
ps_expec_seq <- subset_samples(ps, sample_names(ps) == "D0")
ps_expec_seq <- prune_taxa(taxa_sums(ps_expec_seq) > 0, ps_expec_seq)

# remove 9 ASVs that are low level contaminant in D0
mock_taxa = names(sort(taxa_sums(mock_ps_pure), decreasing = TRUE)[1:9])
# subset the taxa in mock_ps_pure so only the expected sequences are present
mock_ps_pure <- prune_taxa(mock_taxa, mock_ps_pure)

```


```{r}
ps <- merge_phyloseq(blank_ps, mock_ps)
ps

sample_data(ps)$X.SampleID <- sample_names(ps) %>% as.character

#sample_names(ps) <- sample_data(ps)$X.SampleID %>% as.character
```


```{r}
if(dim(otu_table(ps))[1]!=ntaxa(ps)){otu_table(ps) <- t(otu_table(ps))}
```


```{r adding_blocks}
blocks <- rep("blk1", times = nsamples(ps))
sample_data(ps)$block <- blocks
```

```{r}
names(sample_data(ps))[which(names(sample_data(ps))=="Description")] <- "Sample_Type"
```


```{r filter_taxa}
ps <- prune_taxa(taxa_sums(ps)>0, ps)
ps_plasma <- subset_samples(ps, Sample_Type %in% c("Mock"))

if(dim(otu_table(ps_plasma))[1]!=ntaxa(ps_plasma)){otu_table(ps_plasma) <- t(otu_table(ps_plasma))}

prevTaxaP <- apply(otu_table(ps_plasma), 1 ,function(x){sum(x>0)})

Contaminants1 <- names(prevTaxaP)[prevTaxaP==0]
ps <- prune_taxa(prevTaxaP > 0, ps)
ps
```

```{r}
table(sample_data(ps)$Sample_Type,sample_data(ps)$block)
```


```{r}
psBlockResult <- psBlockResults(ps, sampleTypeVar = "Sample_Type", caselevels = c("Mock"), controllevel= "Blank", sampleName = "X.SampleID", blockVar = "block")

psByBlock <- psBlockResult[[1]]
psNCbyBlock <- psBlockResult[[2]]
psallzeroInNC <- psBlockResult[[3]]
psPlByBlock <- psBlockResult[[4]]

saveRDS(psByBlock,"./Results/psByBlock.rds")
```


```{r}
alphaBetaNegControl <- lapply(psNCbyBlock, function(x) {

            ps.to.dq <- phyloseq_to_deseq2(x, design = ~1)

            geo.mean <- function(y) {
                    if(all(y == 0)){
                            val <- 0
                    }else{
                            val <- exp(sum(log(y[y > 0]))/length(y))
                    }
                    return(val)
            }

            geom.mean.row <- apply(counts(ps.to.dq), 1, FUN = geo.mean)

            ps.to.dq <- estimateSizeFactors(ps.to.dq, geoMeans = geom.mean.row)

            library.size.norm <- sizeFactors(ps.to.dq)

            ot.tab <- t(t(otu_table(x))/library.size.norm)

            S_j0 <- round(median(colSums(ot.tab)), digits = 0)

            mu_ij_0_all <- as.numeric(otu_table(x)) %>% data.frame

            mu_ij_0 <- apply(mu_ij_0_all, 1, function(x){
                    if(all(is.na(x))){
                            NA
                    }else{
                            median(x, na.rm = T)
                    }

            })

            gamma_ij_0 <- rep(1,length(mu_ij_0))

            species_name <- taxa_names(x)

            sample_mean <- apply(ot.tab, 1, function(y){
                    if(all(y == 0)){
                            0
                    }else{
                            mean(y[y > 0])
                    }
            })

            sample_var <- apply(ot.tab, 1, function(y){
                    if(all(y == 0)){
                            0
                    }else{
                            var(y)
                    }
            })

            disp <- numeric(0)

            for(i in 1:length(sample_var)){
                    disp[i] <- (sample_var[i] - sample_mean[i])/(sample_mean[i])^2
            }

            alpha_ij_0 <- rep(1e-04, length(mu_ij_0))
            beta_ij_0 <- rep(1, length(mu_ij_0))

            ind_not_na_of_mu_ij_0 <- which(!is.infinite(mu_ij_0))

            #ind_less_one_mu_ij_0 <- which(abs(mu_ij_0) < 1)

            alpha_ij_0[ind_not_na_of_mu_ij_0] <- 1/gamma_ij_0[ind_not_na_of_mu_ij_0]
            beta_ij_0[ind_not_na_of_mu_ij_0] <- 1/(gamma_ij_0[ind_not_na_of_mu_ij_0] *
                            mu_ij_0[ind_not_na_of_mu_ij_0])

           # alpha_ij_0[ind_less_one_mu_ij_0] <- 1/disp[ind_less_one_mu_ij_0]
            #beta_ij_0[ind_less_one_mu_ij_0] <- 1/(gamma_ij_0[ind_less_one_mu_ij_0]*sample_mean[ind_less_one_mu_ij_0])


        out <- list(mu_ij_0, gamma_ij_0, S_j0, species_name, sample_mean,
            sample_var, alpha_ij_0, beta_ij_0)
        names(out) = c("mu_ij_0", "gamma_ij_0", "S_j0", "species_name", "sample_mean",
            "sample_var", "alpha_ij_0", "beta_ij_0")
        return(out)
    })
```

```{r}
num_blks <- length(alphaBetaNegControl)
blks <- seq(1, num_blks) %>% as.list

gammaPrior_all_blks <- lapply(blks, function(x){
        gammaPrior <- alphaBetaContInPlasma(psPlByBlock = psPlByBlock, psallzeroInNC = psallzeroInNC, blk = x, alphaBetaNegControl=alphaBetaNegControl)
        return(gammaPrior)
})
```


```{r sampling_post_true_int}
t1 <- proc.time()

post_all_blocks <- lapply(blks,function(x){
        post_int_all_taxa <- samplingPosterior(psPlByBlock = psPlByBlock,
                blk = x,
                gammaPrior_Cont = gammaPrior_all_blks[[x]],
                itera = 10000,
                ncores = ncores)
        return(post_int_all_taxa)
})

proc.time()-t1


gammaPrior_posTrueSing_all_blocks <- list(gammaPrior_all_blks,post_all_blocks)

saveRDS(gammaPrior_posTrueSing_all_blocks, file= "./Results/gammaPrior_posTrueSing_Mock.rds")
```


```{r make_tables}
itera <- 10000
burnIn <- 5000
cov_pro <- .95
mak_tab <- TRUE # need to change to TRUE if you want to make tables
#psByBlock <- readRDS("./Results_BARBI_8_28_18/psByBlock.rds")
num_blks <- length(psByBlock)

gammaPrior_posTrueSing_all_blocks <- readRDS("./Results/gammaPrior_posTrueSing_Mock.rds")

# gammaPrior_posTrueSing_all_blocks is a list that contains first element posterior sampling, second element is the samples in negative control, plasma
gammaPrior_all_blks <- gammaPrior_posTrueSing_all_blocks[[1]]
post_all_blocks <- gammaPrior_posTrueSing_all_blocks[[2]]


all_real_taxa_lt <- list()

df_blk <- list()

for(blk in 1:num_blks){

                taxa_post_all_sam <- post_all_blocks[[blk]]
                gammPrior <- gammaPrior_all_blks[[blk]]

                total_summary_table <- NULL

                all_real_taxa <- list()
                
                df <- list()

                for(sam in 1:nsamples(psPlByBlock[[blk]])){

  
                        taxa_post <- taxa_post_all_sam[[sam]]
                        acceptance <- list() #  acceptance rate of MC sampling 
                        exp_post_s <- list()
                        lower_s <- list() # s true signal
                        upper_s <- list()
                        lower_b <- list() # b- contaminat
                        upper_b <- list()
                        all_zero_nc <- list()
                        
        
                        for(taxa in 1:length(taxa_post)){
                                
                                burnIn  <- burnIn
                                acceptance[[taxa]]  <-  1-mean(duplicated(taxa_post[[taxa]][-(1:burnIn),]))

                                exp_post_s[[taxa]] <- mean(taxa_post[[taxa]][-(1:burnIn),])

                                hdi_v <- hdi(taxa_post[[taxa]][-(1:burnIn),], credMass = cov_pro)
                                lower_s[[taxa]] <- round(hdi_v[1], digits = 0)
                                upper_s[[taxa]] <- round(hdi_v[2], digits = 0)
                                b_int <- rgamma((itera-burnIn+1), shape = gammPrior[[sam]][[1]][taxa], rate = gammPrior[[sam]][[2]][taxa])

                                hdi_b <- hdi(b_int, credMass = cov_pro)
                                lower_b[[taxa]] <- round(hdi_b[1], digits = 0)
                                upper_b[[taxa]] <- round(hdi_b[2], digits = 0)

                                all_zero_nc[[taxa]] <-  gammPrior[[sam]][[5]][taxa]
                                
                        }


                        df[[sam]] <- data.frame(Species = taxa_names(psPlByBlock[[blk]]),
                                         xj = as.numeric(gammPrior[[sam]][[3]]),
                                         l_s = unlist(lower_s),
                                         u_s = unlist(upper_s),
                                         l_b = unlist(lower_b),
                                         u_b = unlist(upper_b),
                                         all_zero_nc = unlist(all_zero_nc)
                                         )

                        df[[sam]] <- arrange(filter(df[[sam]], ((l_s > u_b)&(l_s>0))), desc(xj))


                        if(dim(df[[sam]])[1]==0){
                                df[[sam]] <- data.frame(Species="Negative",
                                                 xj="Negative",
                                                 l_s="Negative",
                                                 u_s="Negative",
                                                 l_b ="Negative",
                                                 u_b="Negative",
                                                 all_zero_nc = "Negative")
                        }


                        all_real_taxa[[sam]] <- as.character(df[[sam]]$Species)
                       
                }

                all_real_taxa_lt[[blk]] <- all_real_taxa
                
                df_blk[[blk]] <- df
        }

```


```{r}
shouldBeremoved <- df_blk[[1]][[1]]$Species[df_blk[[1]][[1]]$xj <= 60] %>% as.character
```

```{r}
#number of not contaminant ASVs found by BARBI in each sample
lapply(all_real_taxa_lt[[1]], function(y){
  length(y)
})

#number of contaminant ASVs found by BARBI in each sample
lapply(all_real_taxa_lt[[1]], function(y){
  sum(!(taxa_names(contaminants_ps) %in%  y))
})

#number of contamminant ASVs found by BARBI as real ASVs
lapply(all_real_taxa_lt[[1]], function(y){
  sum((y %in% taxa_names(contaminants_ps)))
})

```


```{r}
# did we find all real ASV in each sample
lapply(all_real_taxa_lt[[1]], function(y){
  sum(y  %in% taxa_names(mock_ps_pure))
})

```



```{r}
#Now, we use the contaminants_ps object to evaluate the number contaminant ASVs that are present in the blank control sample.
print(paste('Total number of contaminant ASVs', length(taxa_names(contaminants_ps))))

print(paste('Number of contaminant ASVs also present in blank', length(intersect(taxa_names(contaminants_ps),taxa_names(blank_ps)))))

# create a list of contaminants taxa that are not present in the blank control
contaminant_taxa_no_blank <- taxa_names(contaminants_ps)

contaminant_taxa_no_blank <- contaminant_taxa_no_blank[!(contaminant_taxa_no_blank %in% taxa_names(blank_ps))]

# Create  a binary list of contaminant ASVs indicating if the ASV is present in the blank control (1) or not (0)
contaminants_in_blank <- data.frame(matrix(1, ncol = length(taxa_names(contaminants_ps)), nrow = 1))
colnames(contaminants_in_blank) <- taxa_names(contaminants_ps)
contaminants_in_blank[,contaminant_taxa_no_blank] <- 0
contaminants_in_blank <- t(contaminants_in_blank)

#there are a lot of contaminant ASVs present in the dilution series that aren’t in the blank control sample.
#We also determined the proportion of contaminant ASVs that are not found in the blank control to help us identify the actual impact of these.
```



```{r}
#BARBI identified real species that are contaminant but not in blank control

#number of contamminant ASVs found by BARBI as real ASVs
lapply(all_real_taxa_lt[[1]], function(y){
  sum((y %in% taxa_names(contaminants_ps)))
})

lapply(all_real_taxa_lt[[1]], function(y){
 length(intersect(y[which(y %in% taxa_names(contaminants_ps))], contaminant_taxa_no_blank))
})


```


There is one real ASV is missing in D9 because the abudnance is smaller than that in blank control. This could be avoided by having more blank control and accurately estimate shape and scale parameters. 

We used the estimate of mean in blank control is the observed abundance and dispersion is 1. Thus, $\alpha_0 = 1$ and $\beta_{0} = 1/\mu_{0}$. However, $\alpha_0/\beta_{0} = \mu_{0}$ Then, using the scaling property, $\alpha_c/\beta_{c} = \frac{S_{j}}{S_{j0}}.\frac{\alpha_0}{\beta_{0}}.$

The most of the ASVs wrongly identified as real ASVs not in the blank control. So BARBI needs more than one blank control. 

```{r}
sessionInfo()
```

