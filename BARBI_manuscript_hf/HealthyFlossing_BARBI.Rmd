---
title: 'Healthy Flossing BARBI Analysis'
author: "PJ, FS, HC, SH"
date: '`r format(Sys.time(), "%B %d, %Y")`'
output: 
    html_document:
        toc: true
---

We use the median of $S_{j}^{0}$ of negative control samples and max of $\mu_{ij}^{0}$ of negative control samples. In the second batch, there are two water negative control samples with library size in hundreds. 

```{r include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r install_packages, eval=FALSE}
pkgs <- c("DESeq2","phyloseq","dplyr",
          "tidyr","R.utils","BiocParallel",
          "doParallel","parallel","HDInterval",
          "grid","xtable","gtable",
          "gridExtra","BiocStyle","magrittr",
          "devtools")

if (!requireNamespace("BiocManager")){
  install.packages("BiocManager")
}
    
BiocManager::install(setdiff(pkgs, installed.packages()), update = TRUE)

devtools::install_github("PratheepaJ/BARBI",auth_token = "33c5f43cc3f1772c19a441e15fc9478c3bf91b67")
```


Load packages:
```{r load_packages}
#library(BARBI)
library(devtools)
library(phyloseq)
library(DESeq2)
library(dplyr)
library(tidyr)
library(R.utils)
library(BiocParallel)
library(doParallel)
library(parallel)
library(HDInterval)
library(grid)
library(xtable)
library(gtable)
library(gridExtra)
library(BiocStyle)
library(magrittr)
library(ggplot2)
sourceDirectory("./R")
#sourceDirectory("/Users/jpratheepa31/Dropbox/GitHub/BARBI/R")
```


Set the computational resources
```{r}
t1 <- proc.time()
ncores <- as.integer(Sys.getenv("SLURM_NTASKS"))
if(is.na(ncores)) ncores <- parallel::detectCores()

ncores
```

##      Load the phyloseq object

Load R file to create a phyloseq object from Kraken files: (this directory should be set according to the files directory). I saved the phyloseq object as ``pshf.rds``. 


Read phyloseq object pshf.rds
```{r read-phyloseq}
ps <- readRDS("./Data/pshf.rds")
ps
if(dim(otu_table(ps))[1]!=ntaxa(ps)){otu_table(ps) <- t(otu_table(ps))}
```




###  Identifying batches

In a previous PCoA analysis of this dataset, the samples separated into two separate clusters, which correlated with two groups of DNA extraction batches. 

To reduce the batch-effects of contamination, we specified two "blocks" of samples, and analyzed each block separately with BARBI. 

```{r adding_blocks}
set1 <- c("FL002","FL003","FL004","FL005")
set2 <- c("FL006","FL007","FL008","FL009","FL010","FL011")

#       the following negative controls are in set 2 only.
nctrl <- c("Water.Keck.1","Phix.1","Phix.2","Water.ctrl.1","Water.ctrl.2")

ext.num <- sample_data(ps)$SubjectName
blocks <-ifelse(ext.num %in% set1, "Set1", "Set2")

sample_data(ps)$block <- blocks
```


Subset samples such that only patient plasma and negative control samples are included in the final phyloseq object. 

```{r choose_samples}
ps <- subset_samples(ps,Sample_Type %in% c("Plasma", "Control"))
```


###  Total reads 

Compute total reads in each plasma and negative control sample. Bowtie2 is then used to identifed non-human reads. 

```{r}
sample_data(ps)$Reads <- as.numeric(gsub(",","",sample_data(ps)$Reads))
summary(sample_data(subset_samples(ps, Sample_Type == "Plasma"))$Reads)/(2*10^6)
summary(sample_data(subset_samples(ps, Sample_Type == "Control"))$Reads)/(2*10^6)
```


### Non-human reads (in ten thousands)

```{r}

sample_data(ps)$Non.Human.Reads[which(sample_data(ps)$Non.Human.Reads < 0)] <- -1 *sample_data(ps)$Non.Human.Reads[which(sample_data(ps)$Non.Human.Reads < 0)]
summary(sample_data(subset_samples(ps, Sample_Type == "Plasma"))$Non.Human.Reads)/(2*10^4)
summary(sample_data(subset_samples(ps, Sample_Type == "Control"))$Non.Human.Reads)/(2*10^6)
```


###  heatmap

```{r}
ps.top <- ps 

# do arcsinh transformation
ot <- otu_table(ps.top) %>% data.frame %>% as.matrix

geo_mean <- function(x) {
        if(all(x == 0)){
            val <- 0
        }else{
            val <- exp(sum(log(x[x > 0]))/length(x))
        }
        return(val)
    }

geom_mean_row <- apply(ot, 1, FUN = geo_mean)


sj <- estimateSizeFactorsForMatrix(ot, median, geoMeans = geom_mean_row)
ot.trans <- t(asinh(t(ot)/sj))
ps.top <- phyloseq(otu_table(ot.trans, taxa_are_rows = TRUE), sample_data(ps.top), tax_table(ps.top))
    
# choose top 30 species in plasma samples for heatmap
top <- names(sort(taxa_sums(subset_samples(ps.top, Sample_Type == "Plasma")), decreasing=TRUE))[1:30]

ps.top <- prune_taxa(top, ps.top)
otu_table(ps.top) <- otu_table(ps.top) +1

# order sample by plasma and control
df <- data.frame(sample_data(ps)$SampleCode, sample_data(ps)$Sample_Type)
df <- df[order(df$sample_data.ps..Sample_Type),]
sam.order <- as.character(df$sample_data.ps..SampleCode)

sample_data(ps.top)$block <- factor(sample_data(ps.top)$block)
levels(sample_data(ps.top)$block) <- c("Set 1", "Set 2")
# p <- plot_heatmap(ps.top, sample.label = "SampleCode", taxa.label="Species", taxa.order = top, sample.order = sam.order) + geom_tile() +
#   guides(fill = guide_legend(title="asinh")) + 
#   facet_grid(~block+Sample_Type, scales = "free_x") + 
#   theme(strip.background = element_blank(), axis.text = element_text(size = 10), strip.text = element_text(size = 10)) +
#   xlab("Sample Code")
# 
# p <- p+ theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())
# p

p <- plot_heatmap(ps.top, sample.label = "SampleCode",
  taxa.label = "Species", taxa.order = top, sample.order = sam.order, low = "white",high = "black") +
  geom_tile() + 
  guides(fill = guide_legend(title="arcsinh")) + 
  facet_grid(~ block + Sample_Type, scales = "free_x") + theme(strip.background = element_blank(), axis.text = element_text(size = 8))

p <- p + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())
p
ggsave("./Figures/heatmap_hf_top_2.eps", plot = p, width = 10, height = 8)
```

###  Preprocessing

Identify the species that are not present in at least one plasma sample and removed them from the phyloseq object. Label these species as contaminants. 

```{r filter_taxa}
ps <- prune_taxa(taxa_sums(ps) > 0, ps)
ps_plasma <- subset_samples(ps,Sample_Type %in% c("Plasma"))
prevTaxaP <- apply(otu_table(ps_plasma), 1 ,function(x){sum(x>0)})

Contaminants1 <- names(prevTaxaP)[prevTaxaP == 0]
ps <- prune_taxa(prevTaxaP > 0, ps)
```

Contaminants1 contains a list of taxa that are zero prevalence in plasma samples. (identified before applying BARBI)

Check the distribution of library size/sample depth to see whether there are plasma samples with very small library sizes that should be dropped from the analysis.

```{r samples-plasma}
totalReads <- colSums(otu_table(subset_samples(ps, Sample_Type == "Plasma")))
hist(log(totalReads),yaxs="i",xaxs="i",main="Distribution of total reads per sample", breaks=50)
```


```{r samples-ctrl}
totalReads <- colSums(otu_table(subset_samples(ps, Sample_Type == "Control")))
hist(log(totalReads),yaxs="i",xaxs="i",main="Distribution of total reads per sample", breaks=50)
```

See a summary of the plasma and negative control samples in each block. 

```{r summary_stat}
table(sample_data(ps)$Sample_Type, sample_data(ps)$block)
```

#       Bayesian Inference 

##      Prepare the phyloseq object for the Bayesian inference

We use Bayesian inference to identify contaminants in each block separately to account for the batch-effects of contamination. 

Thus, split the phyloseq object into multiple phyloseq objects corresponding to each block, and store the phyloseq objects as a list of phyloseq objects, `psByBlock`. 

Select negative control samples from each block and store as a list of phyloseq objects, `psNCbyBlock`. 

Select all species that have a prevalence of zero (i.e., have zero reads) in all negative control samples for each block and store as a list of phyloseq objects, `psallzeroInNC`.

Select all plasma samples from each block and store as a list of phyloseq objects, `psPlByBlock`.

```{r list-of-phyloseq}
psBlockResult <- psBlockResults(ps, sampleTypeVar = "Sample_Type", caselevels = c("Plasma"), controllevel= "Control", sampleName = "SampleCode", blockVar = "block")

psByBlock <- psBlockResult[[1]]
psNCbyBlock <- psBlockResult[[2]]
psallzeroInNC <- psBlockResult[[3]]
psPlByBlock <- psBlockResult[[4]]

saveRDS(psByBlock,"./Results/psByBlock.rds")
```

##      Estimate the distribution parameters for the instensity of contamination in negative control samples

Estimate the gamma distribution parameters for the intensity of contaminants using the negative control samples for each block.

1) Estimate mean $\mu_{ij}^{0}$ and dispersion $\gamma_{i}^{0}$.

2) Find the shape $\alpha_{ij}^{0}$ and rate $\beta_{ij}^{0}$ parameters.

3) Median of normalized library sizes $S_{j}^{0}$.

Choose option `stringent = FALSE` to not using sample mean (of non-zero abundances) if the estiamted mean is less than one in negative control samples.

```{r estimate-cont-intensity-ncontrols}
alphaBetaNegControl <- alphaBetaNegControl(psNCbyBlock = psNCbyBlock, stringent = FALSE)

saveRDS(alphaBetaNegControl, "./Results/alphaBetaNegControl.rds")
```


##      Estimate the distribution parameters for the intensity of contamination in each plasma sample

For each plasma sample, estimate the gamma distribution parameters for the intensity of contamination using the scaling property of the gamma distribution.

1) Find the shape $\alpha_{ij}^{c} = \frac{S_{j}}{S^{0}} \alpha_{ij}^{0}$ and rate $\beta_{ij}^{0} = \beta_{ij}^{c}$ parameters.


```{r estimate-cont-intensity-in-each-plasma}
num_blks <- length(alphaBetaNegControl)
blks <- seq(1, num_blks) %>% as.list

gammaPrior_all_blks <- lapply(blks, function(x){
        gammaPrior <- alphaBetaContInPlasma(psPlByBlock = psPlByBlock, psallzeroInNC = psallzeroInNC, blk = x, alphaBetaNegControl = alphaBetaNegControl)
        return(gammaPrior)
})
proc.time()-t1

saveRDS(gammaPrior_all_blks, "./Results/gammaPrior_all_blks.rds")
```


##      Sampling from the posterior for the intensity of true signal

For all samples and for all taxa, sample from the posterior for the intensity of true signal using the Metropolis-Hasting MCMC. Specifify the number of iterations in the MCMC using the option `itera`. 

Save the gamma prior for the intensity of contamination and the posterior samples.

The  suggeseted itera is 10000. 

```{r sampling-post-true-int, eval=FALSE}
t1 <- proc.time()

post_all_blocks <- lapply(blks, function(x){
        post_int_all_taxa <- samplingPosterior(psPlByBlock = psPlByBlock,
                blk = x,
                gammaPrior_Cont = gammaPrior_all_blks[[x]],
                itera = 10000,
                ncores = ncores)
        return(post_int_all_taxa)
})

proc.time()-t1


gammaPrior_posTrueSing_all_blocks <- list(gammaPrior_all_blks,post_all_blocks)

saveRDS(gammaPrior_posTrueSing_all_blocks, file= "./Results/gammaPrior_posTrueSing_all_blocks_hf.rds")
```

#       Display the results

##     Make summaires from the BARBI results.

Choose the number of MCMC to be removed using the option `burnIn`.  It must be less than `itera`.

Choose the coverage probability to construct the highest (posterior) density interval using the option `cov.pro`.

The suggested burnIn is 1000 for itera = 10000.

The output table for each sample displays the following:

-   Species = species names that are not contaminant,
-   xj  =   observed reads for the species in that sample,
-   l_s =   lower limit of the highest (posterior) density interval (credible interval) for the true signal intensity,
(the probability that the true intensity lies between l_s and l_u is the cov.pro)
-   u_s =   upper limit of the highest (posterior) density interval (credible interval) for the true signal intensity,
-   l_b = lower limit of the highest density interval for the contaminant intensity,
-   u_b = upper limit of the highest density interval for the contaminant intensity,
-   all_zero_nc = whether all the negative control samples with zero reads for that particular species

Taxa/ASVs/Species are labeled as contaminants if the lower limit of the true signal (l_s) is greater than the upper limit of the contaminant (u_b). 


```{r make_tables, eval=FALSE}
itera <- 10000
burnIn <- 5000
cov_pro <- .95
mak_tab <- TRUE # need to change to TRUE if you want to make tables
#psByBlock <- readRDS("./Results/psByBlock.rds")
num_blks <- length(psByBlock)

gammaPrior_posTrueSing_all_blocks <- readRDS("./Results/gammaPrior_posTrueSing_all_blocks_hf.rds")

# gammaPrior_posTrueSing_all_blocks is a list that contains first element is the gamma parameters of contaminant intensity in the plasma samples, second element is the posterior sampling 
gammaPrior_all_blks <- gammaPrior_posTrueSing_all_blocks[[1]]
post_all_blocks <- gammaPrior_posTrueSing_all_blocks[[2]]


all_real_taxa_lt <- list()
real.taxa.in.each.sample <- list()

for(blk in 1:num_blks){

                taxa_post_all_sam <- post_all_blocks[[blk]]
                gammPrior <- gammaPrior_all_blks[[blk]]

                total_summary_table <- NULL

                all_real_taxa <- character()

                for(sam in 1:nsamples(psPlByBlock[[blk]])){

                        taxa_post <- taxa_post_all_sam[[sam]]
                        acceptance <- list() #  acceptance rate of MC sampling 
                        exp_post_s <- list()
                        lower_s <- list() # s true signal
                        upper_s <- list()
                        lower_b <- list() # b- contaminant
                        upper_b <- list()
                        all_zero_nc <- list()
                        
        
                        for(taxa in 1:length(taxa_post)){
                                
                                burnIn  <- burnIn
                                acceptance[[taxa]]  <-  1-mean(duplicated(taxa_post[[taxa]][-(1:burnIn),]))

                                exp_post_s[[taxa]] <- mean(taxa_post[[taxa]][-(1:burnIn),])

                                hdi_v <- hdi(taxa_post[[taxa]][-(1:burnIn),], credMass = cov_pro)
                                lower_s[[taxa]] <- round(hdi_v[1], digits = 0)
                                upper_s[[taxa]] <- round(hdi_v[2], digits = 0)
                                b_int <- rgamma((itera-burnIn+1), shape = gammPrior[[sam]][[1]][taxa], rate = gammPrior[[sam]][[2]][taxa])

                                hdi_b <- hdi(b_int, credMass = cov_pro)
                                lower_b[[taxa]] <- round(hdi_b[1], digits = 0)
                                upper_b[[taxa]] <- round(hdi_b[2], digits = 0)

                                all_zero_nc[[taxa]] <-  gammPrior[[sam]][[5]][taxa]
                                
                        }


                        df <- data.frame(Species=taxa_names(psPlByBlock[[blk]]),
                                         xj = as.numeric(gammPrior[[sam]][[3]]),
                                         l_r = unlist(lower_s),
                                         u_r = unlist(upper_s),
                                         l_c = unlist(lower_b),
                                         u_c = unlist(upper_b),
                                         prev_zero_nc = unlist(all_zero_nc)
                                         )

                        df <- arrange(filter(df, ((l_r > u_c)&(l_r > 0))), desc(xj))


                        if(dim(df)[1]==0){
                                df <- data.frame(Species="Negative",
                                                 xj="Negative",
                                                 l_r="Negative",
                                                 u_r="Negative",
                                                 l_c ="Negative",
                                                 u_c="Negative",
                                                 prev_zero_nc = "Negative")
                        }


                        all_real_taxa <- c(all_real_taxa,
                                           as.character(df$Species))
                        
                        #### make tables
                        if(mak_tab){
                                filname <- paste0("./Results/", sample_names(psPlByBlock[[blk]])[sam], ".png")

                                png(filname, height = 600, width = 750)

                                df_p <- tableGrob(df)
                                
                                title <- textGrob(sample_names(psPlByBlock[[blk]])[sam], gp = gpar(fontsize = 12))

                                padding <- unit(0.5,"line")

                                df_p <- gtable_add_rows(
                                        df_p, heights = grobHeight(title) + padding, pos = 0
                                )

                                df_p <- gtable_add_grob(
                                        df_p, list(title),
                                        t = 1, l = 1, r = ncol(df_p) 
                                )

                                grid.newpage()
                                grid.draw(df_p)
                                dev.off()
                        }


                        all_real_taxa <- unique(all_real_taxa)
                        
                }

                all_real_taxa_lt[[blk]] <- all_real_taxa
        }

```


##      Construct a phyloseq object with the true signal and plasma samples
```{r make_phyloseq, eval=FALSE}
saveRDS(all_real_taxa_lt, "./Results/all_real_taxa_hf.rds")
all_real_taxa_lt <- readRDS("./Results/all_real_taxa_hf.rds")
all_real_taxa_lt <- unlist(all_real_taxa_lt)
all_real_taxa_lt <- all_real_taxa_lt[which(!all_real_taxa_lt=="Negative")]
ps_decon <- prune_taxa(all_real_taxa_lt, subset_samples(ps, Sample_Type %in% "Plasma"))
saveRDS(ps_decon,"./Results/ps_decon.rds")
```

### 
```{r eval=FALSE}
sample_data(ps_decon)$block <- factor(sample_data(ps_decon)$block)
levels(sample_data(ps_decon)$block)
ps_decon_blk1 <- subset_samples(ps_decon, block == "Set1")
ps_decon_blk1 <-prune_taxa(taxa_sums(ps_decon_blk1) > 0, ps_decon_blk1)
ps_decon_blk1  
#View(otu_table(ps_decon_blk1) %>% data.frame)

ps_decon_blk2 <- subset_samples(ps_decon, block == "Set2")
ps_decon_blk2 <-prune_taxa(taxa_sums(ps_decon_blk2) > 0, ps_decon_blk2)
ps_decon_blk2 


```

###  A list of contaminants
```{r eval=FALSE}
contaminants <- taxa_names(ps)[!(taxa_names(ps) %in% taxa_names(ps_decon))]
saveRDS(contaminants,"./Results/contaminants_hf.rds")
```


##  Histograms
```{r}
library(tidyr)
itera <- 10000
burnIn <- 5000
cov_pro <- .95
mak_tab <- TRUE # need to change to TRUE if you want to make tables
#psByBlock <- readRDS("./Results/psByBlock2.rds")

gammaPrior_posTrueSing_all_blocks <- readRDS("./Results/gammaPrior_posTrueSing_all_blocks_hf.rds")

gammaPrior_all_blks <- gammaPrior_posTrueSing_all_blocks[[1]]
post_all_blocks <- gammaPrior_posTrueSing_all_blocks[[2]]

blk <- 1

taxa_post_all_sam <- post_all_blocks[[blk]]
gammPrior <- gammaPrior_all_blks[[blk]]


sample.names <- sample_names(psPlByBlock[[blk]])

for(j in 1: length(sample.names)){
    desired.sample.name <- sample.names[j]
    desired.sample.index <- which(sample_names(psPlByBlock[[blk]]) %in% desired.sample.name)
    tax_interested <- rownames(sort(otu_table(psPlByBlock[[blk]])[,desired.sample.index],decreasing = TRUE))[c(1:16)]
    tax_interested_ind <- which(as.character(taxa_names(psPlByBlock[[blk]])) %in% tax_interested)
    tax_names <- taxa_names(psPlByBlock[[blk]])[tax_interested_ind]
    #tax_names <- df.ASV$ASV.Genus[which(as.character(df.ASV$ASV.Genus.Species) %in%  tax_names)]
    
    
    taxa.post <- taxa_post_all_sam[[desired.sample.index]]
    
    burnIn <- 5001
    signal.hist <- taxa.post[tax_interested_ind]
    signal.hist <- lapply(signal.hist,function(x){x[-(1:burnIn),]})
    signal.df <- data.frame(do.call("cbind", signal.hist))
    colnames(signal.df) <- tax_names
    signal.df$group <- rep("True",length=dim(signal.df)[1])
    
    bg <- list()
    for(ind in 1:length(tax_interested_ind)){
            bg[[ind]] <- rgamma(5000, shape=gammPrior[[desired.sample.index]][[1]][tax_interested_ind[ind]],rate = gammPrior[[desired.sample.index]][[2]][tax_interested_ind[ind]])
    }
    
    bg.df <- data.frame(do.call("cbind",bg))
    colnames(bg.df) <- tax_names
    bg.df$group <- rep("Contaminant",length=dim(bg.df)[1])
    
    bg.signal <- rbind(signal.df, bg.df)
    bg.signal$group <- as.factor(bg.signal$group)
    bg_sig_long <- tidyr::gather(bg.signal,key="Taxa",value="Reads",1:(dim(bg.signal)[2]-1))
    bg_sig_long$Taxa <- as.factor(bg_sig_long$Taxa)
    
    # p <- ggplot(bg_sig_long, aes(x= Reads))+
    #         geom_density(aes(y = ..scaled.., fill = group, color = group))+
    #         facet_wrap(~Taxa,scales = "free")+
    #         scale_fill_manual(values=c("blue","brown"))+
    #         scale_color_manual(values=c("blue","brown"))+
    #         ggtitle(desired.sample.name)+
    #         theme(plot.title = element_text(hjust = 0.5), legend.title=element_blank(), strip.text.x = element_text(size=5),strip.background = element_blank(), panel.grid = element_blank()) + xlab("") + ylab("density")
    
    # p <- ggplot(bg_sig_long, aes(x= Reads))+
    #         geom_density(aes(y = ..scaled.., linetype = group))+
    #         facet_wrap(~Taxa,scales = "free")+
    #         ggtitle(desired.sample.name)+
    #         theme(plot.title = element_text(hjust = 0.5),
    #           legend.title=element_blank(), 
    #           strip.text.x = element_text(size=5),
    #           strip.background = element_blank(), 
    #           panel.grid = element_blank()) + 
    #   xlab("") + 
    #   ylab("density")
    
    p <- ggplot(bg_sig_long, aes(x= Reads))+
            geom_density(aes(y = ..scaled.., linetype = group, fill = group))+ 
      scale_fill_manual(values=c("blue","brown")) +
            facet_wrap(~Taxa,scales = "free")+
            ggtitle(desired.sample.name)+
            theme(plot.title = element_text(hjust = 0.5),
              legend.title=element_blank(), 
              strip.text.x = element_text(size=5),
              strip.background = element_blank(), 
              panel.grid = element_blank()) + 
      xlab("") + 
      ylab("density")
    
    fileN <- paste0("Figures/","block_",blk,"_",desired.sample.name,"_histogram3",".eps")
    ggsave(fileN, plot = p, width = 10, height = 5)
}

```




## Session Info 

```{r session_info}
sessionInfo()
```
